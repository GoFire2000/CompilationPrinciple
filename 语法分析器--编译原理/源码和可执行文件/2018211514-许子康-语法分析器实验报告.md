<h1 align = "center">语法分析器实验报告<h1 align = "center"> </h2>
<h4 align = "center">学院：计算机学院</h4>
<h4 align = "center">班级：2018211310</h4>
<h4 align = "center">姓名：许子康</h4>
<h4 align = "center">学号：2018211514</h4>
<h4 align = "center">时间：2020.12.3</h4>









<h2 align = "center">目录 </h2>

![image-20201204124141209](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204124141209.png)









## 一、实验环境

&emsp;&emsp;编程语言: $C++, YACC$
&emsp;&emsp;编程工具：$Visual Studio Code 1.51.1,  YACC$
&emsp;&emsp;实验环境：$Windows10,ubuntu虚拟机$


## 二、实验内容
&emsp;&emsp;题目：语法分析程序的设计与实现
&emsp;&emsp;实验内容：编写语法分析程序，实现对算术表达式的语法分析。要求所分析算术表达式由如下的文法产生：
$$
\begin{aligned}
&E \rightarrow  E+T | E-T | T\\
&T \rightarrow T*F | T/F | F\\
&F \rightarrow (E) | num\\
\end{aligned}
$$
&emsp;&emsp;实验要求：在对输入的算术表达式进行分析的过程中，依次输出所采用的产生式。



* 本实验共有四种方法，本人对这四种方法均分别编写程序并成功进行语法分析，详见实验报告下面分析。
    * 方法$1$：编写递归调用程序实现自顶向下的分析。
    
    * 方法$2$：编写$LL(1)$语法分析程序，要求如下
        * $(1)$ 编程实现算法$4.2$，为给定文法自动构造分析表。
        * $(2)$ 编程实现算法$4.1$，构造$LL(1)$预测分析程序。
        
    * 方法$3$：编写语法分析程序实现自底向上的分析，要求如下
        * $(1)$ 构造识别该文法所有活前缀的DFA。
        * $(2)$ 构造该文法的$LR$分析表。
        * $(3)$ 编程实现算法$4.3$，构造$LR$分析程序。
        
    * 方法$4$：利用$YACC$自动生成语法分析程序，调用$LEX$自动生成的词法分析程序。
    
        

## 三、实验分析与代码
#### 方法一：编写递归调用程序实现自顶向下的分析
&emsp;&emsp;递归调用程序实现自顶向下的分析，要求文法$G$满足以下两个条件：
* $1$、不含左递归
* $2$、$FIRST(\alpha _i) \bigcap FIRST(\alpha _j)=\phi \quad (i \not= j)$

&emsp;&emsp;初始文法G为:
$$
\begin{aligned}
&E \rightarrow  E+T | E-T | T\\
&T \rightarrow T*F | T/F | F\\
&F \rightarrow (E) | num\\
\end{aligned}
$$
&emsp;&emsp;首先，对文法进行消除左递归操作，提取公因子，消除左递归后得到新的文法$G1$如下:
$$
\begin{aligned}
&E \rightarrow TS \\
&S \rightarrow AS|\# \\
&A \rightarrow +T|-T \\
&T \rightarrow FW \\
&W \rightarrow BW|\# \\
&B \rightarrow *F|/F \\
&F \rightarrow (E)|num \\
\end{aligned}
$$
&emsp;&emsp;计算文法$G1$的$FIRST$集，如下：

$$
\begin{aligned}
&FIRST(E) = \{(,num\} \\
&FIRST(T) = \{(,num\} \\
&FIRST(S) = \{+,-,\#\} \\
&FIRST(A) = \{+,-\} \\
&FIRST(F) = \{(,num\} \\
&FIRST(W) = \{*,/,\#\} \\
&FIRST(B) = \{*,/\} \\
\end{aligned}
$$
&emsp;&emsp;经判断,满足$FIRST(\alpha _i) \bigcap FIRST(\alpha _j)=\phi \quad (i \not= j)$条件，因此可以进行递归调用程序实现自顶向下的分析。
&emsp;&emsp;对每个非终结符$A$,构造分析程序转换图，形成文法$G1$的预测分析程序状态转换图；将预测分析程序状态转换图化简，然后根据状态转换图进行程序设计。

&emsp;&emsp;在进行递归调用程序实现自顶向下的分析过程中，如果对于当前非终结符$A$的分析过程中，分析过程失败，例如后面可以接收的字符和当前缓冲区指向的字符无法匹配，说明分析失败，此时需要进行错误报告。

&emsp;&emsp;递归调用及错误报告程序程序如下：
```c++
int isError = false;
void Error(){
    cout << "Error Occurred!" << endl;
}

int proc_E(){
    puts("E->TS");
    bool tag1 = proc_T();
    bool tag2 = proc_S();
    return tag1 & tag2;
}
int proc_T(){
    puts("T->FW");
    bool tag1 = proc_F();
    bool tag2 = proc_W();
    return tag1 & tag2;
}
int proc_S(){
    int tag = proc_A();
    if(tag == -1) {
        return false;
    }else if(tag == 1){
        return proc_S();
    }
    else {
        puts("S->#");
        return true;
    }
}
int proc_A(){
    if(textStr[Index] == '+' || textStr[Index] == '-'){
        puts("S->AS");
        printf("A->%cT\n", textStr[Index]);
        Index++;
        bool tag = proc_T();
        if(!tag) return -1;
        return true;
    }
    return false;
}
int proc_W(){
    int tag = proc_B();
    if(tag == -1){
        return false;
    }
    else if(tag == 1) {
        return proc_W();
    }
    else {
        puts("W->#");
        return true;
    }
}
int proc_B(){
    if(textStr[Index] == '*' || textStr[Index] == '/'){
        puts("W->BW");
        printf("B->%cF\n", textStr[Index]);
        Index++;
        bool tag = proc_F();
        if(!tag) return -1;
        return true;
    }
    return false;
}

int proc_F(){
    if(textStr[Index] == '('){
        puts("F->(E)");
        Index++;
        bool tag =  proc_E();
        if(textStr[Index] == ')') {
            Index++;
            return tag;
        }
        else return false;
        // Index++;
    }else if(textStr[Index] >= '0' && textStr[Index] <='9'){
        puts("F->num");
        int val = 0;
        while(Index < strlen(textStr) && textStr[Index] >= '0' && textStr[Index] <='9'){
            val = val * 10 + textStr[Index] - '0';
            Index++;
        }
        return true;
    }
    else return false;
}
```
#### 方法二：$LL(1)$语法分析程序
* 方法$2$：编写$LL(1)$语法分析程序，要求如下：
    * $(1)$ 编程实现算法$4.2$，为给定文法自动构造分析表。
    * $(2)$ 编程实现算法$4.1$，构造$LL(1)$预测分析程序。


* 一个文法是$LL(1)$文法，当且仅当对于它的每一个非终结符号$A$，如果$A$有两个以上候选式的话，如果$ A \rightarrow \alpha _1 | \alpha _2 | \cdots | \alpha _n$，同时满足下面两个条件：
    * $(1)$ $FIRST(\alpha _i) \bigcap FIRST(\alpha _j)=\phi \quad (i \not= j)$,即A的任何两个候选式的开头终结符号集合互不相交。
    * $(2)$ 若$\alpha _i \Rightarrow \#$，则$FIRST(\alpha_j)\bigcap FOLLOW(A)=\phi \quad (i \not= j)$，即若$A$的某个候选式可以推导出$\#$，则其他候选式的开头终结符号集合与$A$的跟随符号集合互不相交。

&emsp;&emsp;首先，对读入的原文法$G$进行消除左递归操作，提取公因子，消除左递归后得到新的文法$G1$，然后对新文法$G1$划分终结符和非终结符，如下：

&emsp;&emsp;非终结符$N=\{E,S,A,T,W,B,F\}$
&emsp;&emsp;终结符$T=\{+,-,*,\,(,),num\}$

![image-20201204015516732](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204015516732.png)

&emsp;&emsp;之后，将文法$G1$由字符串转换为标识符和数组形式，存储到$vector$<$int$> $ G[maxn][maxn]$中，其中$G[i][j]$存储的是第$i$个非终结符的第$j$个候选式的信息，候选式以整数标识数组的形式存储。进行此种处理，方便后续求出$FIRST$集合、$FOLLOW$集合，构造$LL(1)$文法的预测分析表和用$LL(1)$文法进行非递归预测分析，处理程序如下：
```c++
void Process(){//将字符串转为标识符和数组
    for(int d = 1; d <= numGra; d++){
        int len = strlen(proG[d]);
        string now = "";
        int i = 0;
        while(i < len && !(proG[d][i] == '-' && proG[d][i + 1] == '>')) {
            now = now + proG[d][i];
            i++;
        }
        int id = strToid[now];
        i += 2;
        while(i < len){
            int j = i;
            while(j < len && proG[d][j] != '|') j++;
            if(proG[d][j] == '|') j--;
            ++Count[id];
            now = "";
            for(int k = i; k <= j; k++){
                now = now + proG[d][k];
                if(strToid[now]) {
                    G[id][Count[id]].push_back(strToid[now]);
                    now = "";
                }
            }
            i = j + 2;
        }
    }
    for(int i = 1; i <= numEle; i++){
        if(Count[i]){
//            printf("%d->", i);
            cout << ele[i].Name << "->";
            for(int j = 1; j <= Count[i]; j++){
                for(int k = 0; k < G[i][j].size(); k++){
//                    printf("%d", G[i][j][k]);
                    cout << ele[G[i][j][k]].Name;
                }
                if(j != Count[i]) printf("|");
            }
            printf("\n");
        }
    }
}

```
&emsp;&emsp;处理字符串之后，就可以进行求解$FISRT$集合和$FOLLOW$集合
&emsp;&emsp;$1、 FIRST$集合求解代码如下：

```c++
bool FindInFirst(int id, int tar){//在id的First集合中找有没有tar
    for(int i = 0; i < First[id].size(); i++) {
        if(tar == First[id][i]) return true;
    }
    return false;
}

void FindFirst(int id){//找id的First集
    if(First[id].size()) return;
    for(int i = 1; i <= Count[id]; i++){
        int be = G[id][i][0];
        if(ele[be].type == 1){
            First[id].push_back(be);
        }else if(ele[be].type == 2){
            First[id].push_back(be);
        }else if(ele[be].type == 0){
            int num = 0;
            bool tag = false;
            for(int j = 0; j < G[id][i].size(); j++){
                int now = G[id][i][j];
                if(now == id) break;
                FindFirst(now);
                for(int k = 0; k < First[now].size(); k++){
                    if(First[now][k] != strToid["#"]) First[id].push_back(First[now][k]);
                }
                if(!FindInFirst(now, strToid["#"])) break;
                num++;
            }
            if(num == G[id][i].size()) First[id].push_back(strToid["#"]);
        }
    }
    sort(First[id].begin(), First[id].end());
    First[id].erase(unique(First[id].begin(), First[id].end()), First[id].end());
}
void QueryFirst(){//求FIRST集
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1){
            First[i].push_back(i);
        }else if(ele[i].type == 0){
            FindFirst(i);
        }
    }
}
```
&emsp;&emsp;$2、FOLLOW$集合求解代码如下：
```c++
bool isQuery[maxn];


void FindFollow(int id){//找id的Follow集
    if(isQuery[id]) return; 
    isQuery[id] = true;
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        for(int j = 1;j <= Count[i]; j++){
            for(int k = 0; k < G[i][j].size(); k++){
                if(G[i][j][k] == id){
                    if(k == G[i][j].size() - 1){
                        if(i == id) continue;
                        FindFollow(i);
                        for(int ii = 0; ii < Follow[i].size(); ii++){
                            Follow[id].push_back(Follow[i][ii]);
                        }
                    }else {
                        int x = G[i][j][k + 1];
                        for(int ii = 0; ii < First[x].size(); ii++){
                            if(First[x][ii] != strToid["#"]) Follow[id].push_back(First[x][ii]);
                        }
                        if(FindInFirst(x, strToid["#"]) && i != id){
                            FindFollow(i);
                            for(int ii = 0; ii < Follow[i].size(); ii++){
                                Follow[id].push_back(Follow[i][ii]);
                            }
                        }
                    }
                }
            }
        }
    }
    
    sort(Follow[id].begin(), Follow[id].end());
    Follow[id].erase(unique(Follow[id].begin(), Follow[id].end()), Follow[id].end());
}

void QueryFollow(){//求Follow集
    Follow[strToid["E"]].push_back(strToid["$"]);
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1) 
            Follow[i].push_back(strToid["$"]);
    }
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 0 && !isQuery[i]){
            // printf("i = %d\n", i);
            FindFollow(i);
        }
    }
}
```
&emsp;&emsp;求解得到的$FIRST$集合和$FOLLOW$集合输出如图：

![image-20201204024142755](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204024142755.png)

&emsp;&emsp;之后，利用已经求解的$FIRST$集合和$FOLLOW$集合构造$LL(1)$文法的预测分析表，即算法$4.2$，求解代码如下：
```c++
vector<int> TableLL1[maxn][maxn];

void CreatePredicitionTableOfLL1(){//构造LL1文法的预测分析表哦
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        for(int j = 1; j <= Count[i]; j++){
            int x = G[i][j][0];
            if(x == strToid["#"] || FindInFirst(x, strToid["#"])){
                for(int k = 0; k < Follow[i].size(); k++){
                    int b = Follow[i][k];
                    TableLL1[i][b].push_back(i);
                    for(int ii = 0; ii < G[i][j].size(); ii++){
                        TableLL1[i][b].push_back(G[i][j][ii]);
                    }
                }
            }
            if(x == strToid["#"]) continue;
            for(int k = 0; k < First[x].size(); k++) if(First[x][k] != strToid["#"]){
                int b = First[x][k];
                TableLL1[i][b].push_back(i);
                for(int ii = 0; ii < G[i][j].size(); ii++){
                    TableLL1[i][b].push_back(G[i][j][ii]);
                }
            }
        }
    }
}
```
&emsp;&emsp;求解得到的$LL(1)$文法的预测分析表如图：

![image-20201204024009788](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204024009788.png)
&emsp;&emsp;有了$LL(1)$文法的预测分析表后，可以进行$LL(1)$文法的非递归预测分析，代码如下：

```c++
void Error(){
    cout << "Error Occurred!" << endl;
}
int sta[maxn];//栈
int top;
void Print(int pos, int len, string strOut){
    string strSta = "";
    string strIn = "";
    // string strOut = "";
    for(int i = 0; i < top; i++) strSta = strSta + ele[sta[i]].Name;
    for(int i = pos; i < len; i++) strIn = strIn + textStr[i];
    cout << "|    " << setw(15) << strSta << "|    " << setw(23) << strIn << "|    " << setw(15) << strOut << "|" <<endl;
    printf("--------------------------------------------------------------------\n");
}
// stack<int> sta;//栈
// stack<int> q;
void NonRecursivePredictionAnalysisOfLL1(){//LL1文法的非递归预测分析
    // while(!sta.empty()) sta.pop();
    printf("--------------------------------------------------------------------\n");
    printf("|     stack         |          input            |     output        |\n");
    printf("--------------------------------------------------------------------\n");
    top = 0;
    int len = strlen(textStr);
    textStr[len++] = '$';
    int i = 0;
    sta[top++] = (strToid["$"]);
    sta[top++] = (strToid["E"]);
    int x;
    Print(0, len, "");
    while(true){
        int x = sta[top - 1];
        if(x == strToid["$"]) break;
        int val = -1;
        char ch = 0;

        string sch = "";
        if(textStr[i] >= '0' && textStr[i] <= '9') sch = "num";
        else sch = sch + textStr[i];

        if(x == strToid["$"] || ele[x].type == 1){//终结符或$
            if(ele[x].Name == sch){
                top--;
                if(sch == "num"){
                    while(textStr[i] >= '0' && textStr[i] <= '9') i++;
                }
                else i++;
                Print(i, len, "");
            }
            else {
                Error();
                return;
            }
        }else {
            int v = strToid[sch];
            if(TableLL1[x][v].size()){
                top--;
                for(int j = TableLL1[x][v].size() - 1; j >= 1; j--){
                    if(TableLL1[x][v][j] != strToid["#"]) sta[top++] = (TableLL1[x][v][j]);
                }
                string strStr = "";
                for(int j = 0; j < TableLL1[x][v].size(); j++){
                    int now = TableLL1[x][v][j];
                    if(j == 0) strStr = strStr + ele[now].Name + "->";//cout << ele[now].Name << "->";
                    else strStr = strStr + ele[now].Name;//cout << ele[now].Name;
                }
                // cout << endl;
                Print(i, len, strStr);

            }else {
                Error();
                return;
            }
        }
    }
    if(i + 1 < len) Error();
    //(123+3213122)/2
}
```
#### 方法三：$LR$语法分析程序实现自底向上的分析
* 方法$3$：编写语法分析程序实现自底向上的分析，要求如下
    * $(1)$ 构造识别该文法所有活前缀的DFA。
    * $(2)$ 构造该文法的$LR$分析表。
    * $(3)$ 编程实现算法$4.3$，构造$LR$分析程序。

&emsp;&emsp;方法一、二分别是自顶向下的递归和非递归分析，而方法三则是自底向上的分析，可以选择的语法分析程序有$SLR、LR(1)$两种分析方法，本人方法三选用的是$LR(1)$语法分析程序。

&emsp;&emsp;首先，要构造文法$G$的拓广文法$G`$,初始文法$G$为:
$$
\begin{aligned}
&E \rightarrow  E+T | E-T | T\\
&T \rightarrow T*F | T/F | F\\
&F \rightarrow (E) | num\\
\end{aligned}
$$
&emsp;&emsp;拓广文法$G`$为:
$$
\begin{aligned}
&0:\quad S \rightarrow  E\\
&1:\quad E \rightarrow E+T\\
&2:\quad E \rightarrow E-T\\
&3:\quad E \rightarrow T\\
&4:\quad E \rightarrow E-T\\
&5:\quad T \rightarrow T*F\\
&6:\quad T \rightarrow T/F\\
&7:\quad T \rightarrow F\\
&8:\quad F \rightarrow (E)\\
&9:\quad F \rightarrow num\\
\end{aligned}
$$
&emsp;&emsp;程序求得的拓广文法如图：

​        ![image-20201204052352886](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204052352886.png)

&emsp;&emsp;同方法二，调用$process()$函数，进行终结符、非终结符的划分，文法的字符串转整形数组和标识，划入如下：
&emsp;&emsp;非终结符$N = \{S,E,T,F\}$
&emsp;&emsp;终结符&emsp;$T=\{+,-,*,/,(,),num\}$

&emsp;&emsp;同方法二，调用$QueryFirst()$和$QueryFollow()$函数，求出文法$G`$的$FIRST$集合和$FOLLOW$集合，调用$PrintFirstAndFollowTable()$输出求得的$FIRST$集合和$FOLLOW$集合，如图：

![image-20201204053017566](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204053017566.png)

&emsp;&emsp;之后，利用求得的$FIRST$集合和$FOLLOW$集合构造识别该文法所有活前缀的$DFA$，构造结果如图：

![image-20201204053524457](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204053524457.png)![image-20201204053545141](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204053545141.png)

&emsp;&emsp;构造识别文法$G`$所有活前缀的$DFA$后，可以得到$0\sim 29$共$30$个状态，由$DFA$构造该文法的$LR(1)$分析表，如图：

![image-20201204053914174](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204053914174.png)

&emsp;&emsp;将上述$LR(1)$分析表导入到程序中，存储在$TableOfLR1[maxn][maxn]$中，将分析表输出，如图：

![image-20201204060836253](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204060836253.png)

&emsp;&emsp;得到该文法的$LR(1)$分析表后，根据分析表，构造$LR(1)$分析程序，即编程实现算法$4.3$，分析程序代码如下:
```c++
void Error(){
    cout << "Error Occurred!" << endl;
}
int staState[maxn], topState;
int staLabel[maxn], topLabel;
// stack<int> staState;//状态栈
// stack<int> staLabel;//符号栈

void Print(int pos, int len, string strOut){
    string strState = "";
    string strLabel = "";
    string strIn = "";
    // string strOut = "";
    for(int i = 0; i < topState; i++) strState = strState + IntToString(staState[i]) + " ";
    for(int i = 0; i < topLabel; i++) strLabel = strLabel + ele[staLabel[i]].Name;
    
    for(int i = pos; i < len; i++) strIn = strIn + textStr[i];
    cout << "|    " << setw(23) << strState << "|    " << setw(23) << strLabel <<"|    " << setw(23) << strIn << "|    " << setw(17) << strOut << "|" <<endl;
    printf("-----------------------------------------------------------------------------------------------------------\n");
}

void AnalysisOfLR1(){//LR1文法的分析
    // while(!staState.empty()) staState.pop();
    // while(!staLabel.empty()) staLabel.pop();
    printf("-----------------------------------------------------------------------------------------------------------\n");
    printf("|        stackState         |        stackSymble        |            input          |        output       |\n");
    printf("-----------------------------------------------------------------------------------------------------------\n");
    topState = 0;
    topLabel = 0;
    int len = strlen(textStr);
    textStr[len++] = '$';
    int i = 0;
    staState[topState++] = (0);
    staLabel[topLabel++] = strToid["#"];
    
    do{
        int x = staState[topState - 1];
        string sch = "";
        if(textStr[i] >= '0' && textStr[i] <= '9') sch = "num";
        else sch = sch + textStr[i];
        if(TableOfLR1[x][strToid[sch]].tp == 'S'){
            string now = "";
            now = now + "Shift " + IntToString(TableOfLR1[x][strToid[sch]].v);
            Print(i, len, now);
            staState[topState++] = (TableOfLR1[x][strToid[sch]].v);
            staLabel[topLabel++] = (strToid[sch]);
            if(sch == "num"){
                while(textStr[i] >= '0' && textStr[i] <= '9') i++;
            }
            else i++;
        }
        else {
            if(TableOfLR1[x][strToid[sch]].tp == 'R'){
                int id = TableOfLR1[x][strToid[sch]].v;
                int num = GS[id].size() - 1;
                string now = "";
                now = now + "reduce by ";
                // GetGS(now, id);
                for(int j = 0; j < GS[id].size(); j++){
                    if(j == 0) {
                        now = now + ele[GS[id][j]].Name + "->";
                    }else {
                        now = now + ele[GS[id][j]].Name;
                    }
                }
                Print(i, len, now);
                for(int j = 1; j <= num; j++) topState--, topLabel--;
                x = staState[topState - 1];
                staLabel[topLabel++] = (GS[id][0]);
                staState[topState++] = (TableOfLR1[x][GS[id][0]].v);
                // PrintGS(id);
            }
            else if(TableOfLR1[x][strToid[sch]].tp == 'A') {
                string now = "";
                now = now + "ACC";
                Print(i, len, now);
                break;
            }
            else {
                Error();
                return;
            }
        }
    }while(true);
    /*
    while(!staLabel.empty()) {
        int x = staLabel.top();
        staLabel.pop();
        cout << ele[x].Name;
    }
    cout << endl;
    */
    
}
```

#### 方法四：利用$YACC$自动生成语法分析程序，调用$LEX$自动生成的词法分析程序
&emsp;&emsp;方法四是在Ubuntu虚拟机环境下编写运行，程序代码$YACC.y$如下：
```c++
%{

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTYPE double	/* doble type for YACC stack; for yylval */

int yylex(void);
int yyerror(char *);

%}

%token NUM

%%

line	:	line expr '\n'	{printf("Success!\n");}
     	|	line '\n'
	|	/* error */
	|	error '\n'	{yyerror("reenter last line:");}
    	;
expr	:	expr '+' term	{$$ = $1 + $3;	printf("E->E+T\n");}
     	|	expr '-' term	{$$ = $1 - $3;	printf("E->E-T\n");}
	|	term		{		printf("E->T\n");}
	;
term	:	term '*' factor	{$$ = $1 * $3;	printf("T->T*F\n");}
     	|	term '/' factor	{$$ = $1 / $3;	printf("T->T/F\n");}
	|	factor		{		printf("T->F\n");}
	;
factor	:	'(' expr ')'	{$$ = $2;	printf("F->(E)\n");}
       	|	NUM	{		printf("F->num\n");}
	;

%%

int yylex() {
  int c;
  while ((c = getchar()) == ' ') ;
  if (c == '.' || isdigit(c)) {
    ungetc(c, stdin);
    scanf("%lf", &yylval);
    return NUM;
  }
  return c;
}

int yyerror(char *s) {
  fprintf(stderr, "error: %s\n", s);
}

int main()
{
  puts("Input your string: ");
  return yyparse();
}

```
&emsp;&emsp;然后，利用$yacc \quad YACC.y$指令，生成$y.tab.c$文件，如图：

![image-20201204055231429](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204055231429.png)

&emsp;&emsp;之后，编译$y.tab.c$文件，生成可执行文件$analyse$，如图：

​	![image-20201204055238446](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204055238446.png)

&emsp;&emsp;利用$analyse$文件即可进行对输入串的语法分析，如图：

![image-20201204055248429](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204055248429.png)


## 四、测试样例及结果
#### 方法一：编写递归调用程序实现自顶向下的分析
&emsp;&emsp;编译运行方法一程序，分别输入正确和错误的算数表达式，观察递归调用程序实现自顶向下分析的过程。
&emsp;&emsp;测试$1$：$3+4 * (2/3-4* 5)-5*4$，结果如图：

![image-20201204060131574](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204060131574.png)

&emsp;&emsp;测试$2$：$4-(3+ * 4)/2$，结果如图：

![image-20201204060215593](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204060215593.png)

#### 方法二：$LL(1)$语法分析程序
&emsp;&emsp;编译运行方法二程序，分别输入正确和错误的算数表达式，观察使用LL(1)语法分析程序实现非递归自顶向下分析的过程。
&emsp;&emsp;测试$1$：$ (2/3-4 * 5)/3-5 * 4$，结果如图：

![image-20201206202940600](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201206202940600.png)

&emsp;&emsp;测试$2$：$(3/ 4+) * 3$，结果如图：

![image-20201206203020074](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201206203020074.png)

#### 方法三：$LR(1)$语法分析程序实现自底向上的分析
&emsp;&emsp;编译运行方法三程序，分别输入正确和错误的算数表达式，观察使用$LR(1)$语法分析程序实现非递归自底向上分析的过程。
&emsp;&emsp;测试$1$：$ (6+4 * 3-5/2)/2+5 * 4$，结果如图：

![image-20201206211148630](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201206211148630.png)



&emsp;&emsp;测试$2$：$ 3+4 * 5)+3 * 6$，结果如图：

![image-20201206211224371](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201206211224371.png)

#### 方法四：利用$YACC$自动生成语法分析程序，调用$LEX$自动生成的词法分析程序
&emsp;&emsp;运行$y.tab.c$生成的$analyse$可执行文件，分别输入正确和错误的算数表达式，观察语法分析的过程。
&emsp;&emsp;测试$1$：$3+(5/3+2 * 4) * 3 - 5$，结果如图：

![image-20201204061632894](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204061632894.png)

&emsp;&emsp;测试$2$：$3+(4/3+2++3)$，结果如图：

![image-20201204061626871](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204061626871.png)

&emsp;&emsp;测试$3$：$3+4/33(3+ * 3)$，结果如图：

![image-20201204061618304](C:\Users\许子康\AppData\Roaming\Typora\typora-user-images\image-20201204061618304.png)

## 五、实验过程中遇到的问题
&emsp;&emsp;在写方法一时，构造并化简分析程序状态转换图后，根据状态转换图进行程序设计，编好代码后发现错误报告功能无法正确实现。经仔细检查排除后发现问题出现在$S \rightarrow AS|\#$ 和 $W \rightarrow BW|\#$ ，由于有非终结符推导到空的存在，因此需要进行特殊判断，比如在$proc\_S()$中要先运行$proc\_A()$函数,根据$proc\_A()$函数的成功与否判断是否要执行$proc\_S()$操作。
&emsp;&emsp;另外，对于类似$A->+T|-T$的操作，需要有三种返回值，分别是表示匹配$+、-$失败，匹配$+、-$成功但$proc\_T()$失败，均成功；$proc\_S()$要跟根据不同的情况做不同的操作，对应三种操作分别是$A->\#$，报错，$S->AS$。
&emsp;&emsp;方法二中，$FOLLOW$集合的求解过程由于没考虑全出现错误，后来改正就可以正确求解。
&emsp;&emsp;方法三，在求完$FIRST$和$FOLLOW$集合后，本来想编程求识别所有活前缀的$DFA$和$LR(1)$预测分析表，后来由于种种原因，选择手写$DFA$和预测分析表，将结果导入到代码中，省去了代码求解过程。
&emsp;&emsp;写方法四时，一是$YACC$不熟悉，二是$Windows10$操作系统不方便，因此熟悉$YACC$后，下载了一个$Ubuntu$虚拟机，在虚拟机上完成了编写编译运行的过程。

## 六、感想
&emsp;&emsp;这次编译原理语法分析器实验，由四个部分组成，每个部分有一定的联系但又互不相同。通过亲自动手真正通过程序编写实现功能，极大地加深了我对从顶向下的递归和非递归分析、自底向上的非递归分析和$YACC、LEX$的理解，发现了一些仅靠自己手写时忽略的细节问题，和词法分析器结合思考，加深了对编译过程的理解，同时提高了我的代码编程能力，增加了将知识真正运用的宝贵经验。总而言之，这次语法分析器实验，我获益匪浅！
## 七、源代码
#### 方法一：编写递归调用程序实现自顶向下的分析
* method1.cpp
```c++
#include <bits/stdc++.h>
#define LL long long
#define Inf 1e9
using namespace std;
const int maxn = 1010;
char textStr[maxn]; //要翻译的串
int Index;//下标
/*
E->E+T|E-T|T
T->T*F|T/F|F
F->(E)|num
.
 */
/*
消除左递归后
E->TS
S->AS|#
A->+T|-T
T->FW
W->BW|#
B->*F|/F
F->(E)|num
.
*/
/*
实验要求：在对输入的算术表达式进行分析的过程中，依次输出所采用的的产生式
方法1：编写递归调用程序实现自顶向下的分析
*/
//递归调用程序实现自顶向下的分析
int proc_E();
int proc_T();
int proc_S();
int proc_F();
int proc_A();
int proc_B();
int proc_W();

int isError = false;
void Error(){
    cout << "Error Occurred!" << endl;
}

int proc_E(){
    puts("E->TS");
    bool tag1 = proc_T();
    bool tag2 = proc_S();
    return tag1 & tag2;
}
int proc_T(){
    puts("T->FW");
    bool tag1 = proc_F();
    bool tag2 = proc_W();
    return tag1 & tag2;
}
int proc_S(){
    int tag = proc_A();
    if(tag == -1) {
        return false;
    }else if(tag == 1){
        return proc_S();
    }
    else {
        puts("S->#");
        return true;
    }
}
int proc_A(){
    if(textStr[Index] == '+' || textStr[Index] == '-'){
        puts("S->AS");
        printf("A->%cT\n", textStr[Index]);
        Index++;
        bool tag = proc_T();
        if(!tag) return -1;
        return true;
    }
    return false;
}
int proc_W(){
    int tag = proc_B();
    if(tag == -1){
        return false;
    }
    else if(tag == 1) {
        return proc_W();
    }
    else {
        puts("W->#");
        return true;
    }
}
int proc_B(){
    if(textStr[Index] == '*' || textStr[Index] == '/'){
        puts("W->BW");
        printf("B->%cF\n", textStr[Index]);
        Index++;
        bool tag = proc_F();
        if(!tag) return -1;
        return true;
    }
    return false;
}

int proc_F(){
    if(textStr[Index] == '('){
        puts("F->(E)");
        Index++;
        bool tag =  proc_E();
        if(textStr[Index] == ')') {
            Index++;
            return tag;
        }
        else return false;
        // Index++;
    }else if(textStr[Index] >= '0' && textStr[Index] <='9'){
        puts("F->num");
        int val = 0;
        while(Index < strlen(textStr) && textStr[Index] >= '0' && textStr[Index] <='9'){
            val = val * 10 + textStr[Index] - '0';
            Index++;
        }
        return true;
    }
    else return false;
}

void Init();
int main(){
    Init();
    return 0;
}
//(4+3)/2+(6+3)*2+4-3
void Init(){
    while(true){
        memset(textStr, 0, sizeof(textStr));
        cout << "Please enter a text string, if you want to exit, please enter #:" << endl;
        scanf("%s", textStr);
        int len = strlen(textStr);
        if(len == 1 && textStr[0] == '#') break;
        Index = 0;
        if(proc_E() == false || Index < len) Error();
        
        // printf("Index = %d\n", Index);
        puts("\nRecursive calling program to achieve top-down analysis is complete!\n\n");
        system("pause");
    }
    //2+(3*1/2+3123)
}
```
#### 方法二：$LL(1)$语法分析程序
* method2.cpp
```c++
#include <bits/stdc++.h>
#define LL long long
#define Inf 1e9
using namespace std;
const int maxn = 1010;
/*
E->E+T|E-T|T
T->T*F|T/F|F
F->(E)|num
.
 */
/*
消除左递归后
E->TS
S->AS|#
A->+T|-T
T->FW
W->BW|#
B->*F|/F
F->(E)|num
.
 */

/*
实验要求：在对输入的算术表达式进行分析的过程中，依次输出所采用的的产生式
方法2： 编写LL(1)语法分析程序，要求如下
 （1）编程实现算法4.2，为给定文法自动构造预测分析表
 （2）编程实现算法4.1，构造LL（1）分析程序
 */
char oriG[maxn][maxn];//存放初始文法内容
int numGra;//文法的数量

char proG[maxn][maxn];//消除左递归后的文法内容

vector<int> G[maxn][maxn];//存放文法
int Count[maxn];//Count[x]表示非终结符x能推导出来的式子数量
map<string, int> strToid;//标识符名字与数字之间的映射

char textStr[maxn]; //要翻译的串

struct Element{
    int type;//type=0为非终结符，type=1为终结符,type=2为空,type=3为结束符号
    string Name;//标识
    Element(){};
    Element(int ttp, string NName){
        type = ttp;
        Name = NName;
    }
}ele[maxn];
int numEle;//终结符和非终结符的数量


vector<int> First[maxn];//First集
vector<int> Follow[maxn];//Follow集



void PreProcess(){//消除左递归，oriG->G
    //ETSAFWB
    ele[1] = Element(0, "E");
    ele[2] = Element(0, "T");
    ele[3] = Element(0, "S");
    ele[4] = Element(0, "A");
    ele[5] = Element(0, "F");
    ele[6] = Element(0, "W");
    ele[7] = Element(0, "B");
    ele[8] = Element(1, "+");
    ele[9] = Element(1, "-");
    ele[10] = Element(1, "*");
    ele[11] = Element(1, "/");
    ele[12] = Element(1, "(");
    ele[13] = Element(1, ")");
    ele[14] = Element(1, "num");
    ele[15] = Element(3, "$");
    ele[16] = Element(2, "#");
    numEle = 16;
    for(int i = 1; i <= numEle; i++) strToid[ele[i].Name] = i;
    numGra += 7;
    for(int i = 1; i <= numGra; i++) {
        string now;
        if (i == 1) now = "E->TS";
        else if (i == 2) now = "S->AS|#";
        else if (i == 3) now = "A->+T|-T";
        else if (i == 4) now = "T->FW";
        else if (i == 5) now = "W->BW|#";
        else if (i == 6) now = "B->*F|/F";
        else if (i == 7) now = "F->(E)|num";
        int len = now.length();
        for(int j = 0; j < len; j++){
            proG[i][j] = now[j];
        }
    }
}

void Process(){//将字符串转为标识符和数组
    for(int d = 1; d <= numGra; d++){
        int len = strlen(proG[d]);
        string now = "";
        int i = 0;
        while(i < len && !(proG[d][i] == '-' && proG[d][i + 1] == '>')) {
            now = now + proG[d][i];
            i++;
        }
        int id = strToid[now];
        i += 2;
        while(i < len){
            int j = i;
            while(j < len && proG[d][j] != '|') j++;
            if(proG[d][j] == '|') j--;
            ++Count[id];
            now = "";
            for(int k = i; k <= j; k++){
                now = now + proG[d][k];
                if(strToid[now]) {
                    G[id][Count[id]].push_back(strToid[now]);
                    now = "";
                }
            }
            i = j + 2;
        }
    }
    for(int i = 1; i <= numEle; i++){
        if(Count[i]){
//            printf("%d->", i);
            cout << ele[i].Name << "->";
            for(int j = 1; j <= Count[i]; j++){
                for(int k = 0; k < G[i][j].size(); k++){
//                    printf("%d", G[i][j][k]);
                    cout << ele[G[i][j][k]].Name;
                }
                if(j != Count[i]) printf("|");
            }
            printf("\n");
        }
    }
}

bool FindInFirst(int id, int tar){//在id的First集合中找有没有tar
    for(int i = 0; i < First[id].size(); i++) {
        if(tar == First[id][i]) return true;
    }
    return false;
}

void FindFirst(int id){//找id的First集
    if(First[id].size()) return;
    for(int i = 1; i <= Count[id]; i++){
        int be = G[id][i][0];
        if(ele[be].type == 1){
            First[id].push_back(be);
        }else if(ele[be].type == 2){
            First[id].push_back(be);
        }else if(ele[be].type == 0){
            int num = 0;
            bool tag = false;
            for(int j = 0; j < G[id][i].size(); j++){
                int now = G[id][i][j];
                if(now == id) break;
                FindFirst(now);
                for(int k = 0; k < First[now].size(); k++){
                    if(First[now][k] != strToid["#"]) First[id].push_back(First[now][k]);
                }
                if(!FindInFirst(now, strToid["#"])) break;
                num++;
            }
            if(num == G[id][i].size()) First[id].push_back(strToid["#"]);
        }
    }
    sort(First[id].begin(), First[id].end());
    First[id].erase(unique(First[id].begin(), First[id].end()), First[id].end());
}
void QueryFirst(){//求FIRST集
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1){
            First[i].push_back(i);
        }else if(ele[i].type == 0){
            FindFirst(i);
        }
    }
}
void PrintFirst(){//输出First集
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        cout << "First(" << ele[i].Name << ") = {";
        for(int j = 0; j < First[i].size(); j++){
            int now = First[i][j];
            if(j != First[i].size() - 1) cout << ele[now].Name << ", ";
            else cout << ele[now].Name;
        }
        cout << "}" << endl;
    }
}

bool isQuery[maxn];


void FindFollow(int id){//找id的Follow集
    if(isQuery[id]) return; 
    isQuery[id] = true;
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        for(int j = 1;j <= Count[i]; j++){
            for(int k = 0; k < G[i][j].size(); k++){
                if(G[i][j][k] == id){
                    if(k == G[i][j].size() - 1){
                        if(i == id) continue;
                        FindFollow(i);
                        for(int ii = 0; ii < Follow[i].size(); ii++){
                            Follow[id].push_back(Follow[i][ii]);
                        }
                    }else {
                        int x = G[i][j][k + 1];
                        for(int ii = 0; ii < First[x].size(); ii++){
                            if(First[x][ii] != strToid["#"]) Follow[id].push_back(First[x][ii]);
                        }
                        if(FindInFirst(x, strToid["#"]) && i != id){
                            FindFollow(i);
                            for(int ii = 0; ii < Follow[i].size(); ii++){
                                Follow[id].push_back(Follow[i][ii]);
                            }
                        }
                    }
                }
            }
        }
    }
    
    sort(Follow[id].begin(), Follow[id].end());
    Follow[id].erase(unique(Follow[id].begin(), Follow[id].end()), Follow[id].end());
}

void QueryFollow(){//求Follow集
    Follow[strToid["E"]].push_back(strToid["$"]);
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1) 
            Follow[i].push_back(strToid["$"]);
    }
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 0 && !isQuery[i]){
            // printf("i = %d\n", i);
            FindFollow(i);
        }
    }
}

void PrintFollow(){//输出Follow集
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0){
        cout << "Follow(" << ele[i].Name << ") = {";
        for(int j = 0; j < Follow[i].size(); j++){
            int now = Follow[i][j];
            if(j != Follow[i].size() - 1) cout << ele[now].Name << ", ";
            else cout << ele[now].Name;
        }
        cout << "}" << endl;
    }
}

void PrintFirstAndFollowTable(){//输出First和Follow表格
    cout << "\nFIRST set and FOLLOW set of grammer G:" << endl;
    printf("---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
    printf("|         |");
    for(int j = 1; j <= numEle; j++) if(ele[j].type == 0){//终结符或$
        cout << "          " << left << setw(11) << ele[j].Name << "|";
    }
    cout << endl;
    printf("---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
    printf("|  FIRST  |");
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        string now = "";
        for(int j = 0; j < First[i].size(); j++){
            now = now + ele[First[i][j]].Name;
            if(j != First[i].size() - 1) now = now + ", ";
        }
        cout << "   " << setw(16) << now << "  |";
    }
    cout << endl;
    printf("---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
    printf("|  FOLLOW |");
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        string now = "";
        for(int j = 0; j < Follow[i].size(); j++){
            now = now + ele[Follow[i][j]].Name;
            if(j != Follow[i].size() - 1) now = now + ", ";
        }
        cout << "   " << setw(16) << now << "  |";
    }
    cout << endl;
    
    printf("---------------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
    printf("\n");
    
}
vector<int> TableLL1[maxn][maxn];

void CreatePredicitionTableOfLL1(){//构造LL1文法的预测分析表哦
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        for(int j = 1; j <= Count[i]; j++){
            int x = G[i][j][0];
            if(x == strToid["#"] || FindInFirst(x, strToid["#"])){
                for(int k = 0; k < Follow[i].size(); k++){
                    int b = Follow[i][k];
                    TableLL1[i][b].push_back(i);
                    for(int ii = 0; ii < G[i][j].size(); ii++){
                        TableLL1[i][b].push_back(G[i][j][ii]);
                    }
                }
            }
            if(x == strToid["#"]) continue;
            for(int k = 0; k < First[x].size(); k++) if(First[x][k] != strToid["#"]){
                int b = First[x][k];
                TableLL1[i][b].push_back(i);
                for(int ii = 0; ii < G[i][j].size(); ii++){
                    TableLL1[i][b].push_back(G[i][j][ii]);
                }
            }
        }
    }
}

void PrintPredicitionTableOfLL1(){//输出LL1文法的预测分析表
    cout << "\nPredicition Analysis Table of grammer G:" << endl;
    printf("----------------------------------------------------------------------------------\n");
    printf("|        |");
    for(int j = 1; j <= numEle; j++) if(ele[j].type == 1 || ele[j].type == 3){//终结符或$
        cout << "    " << left << setw(4) << ele[j].Name << "|";
    }
    cout << endl;
    printf("----------------------------------------------------------------------------------\n");
    
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        cout << "|    " << left << setw(4) << ele[i].Name << "|";
        for(int j = 1; j <= numEle; j++) if(ele[j].type == 1 || ele[j].type == 3){//终结符或$
            if(TableLL1[i][j].size() == 0) {
                cout << "        |";
            }else {
                string now = "";
                for(int k = 0 ; k < TableLL1[i][j].size(); k++){
                    int x = TableLL1[i][j][k];
                    if(k == 0){
                        now = now + ele[x].Name + "->";
                    }else{
                        now = now + ele[x].Name;
                    }
                }
                cout << " " << setw(7) << now << "|";
            }
        }
        cout << endl;
        printf("----------------------------------------------------------------------------------\n");
    }
} 

void Error(){
    cout << "Error Occurred!" << endl;
}
int sta[maxn];//栈
int top;
void Print(int pos, int len, string strOut){
    string strSta = "";
    string strIn = "";
    // string strOut = "";
    for(int i = 0; i < top; i++) strSta = strSta + ele[sta[i]].Name;
    for(int i = pos; i < len; i++) strIn = strIn + textStr[i];
    cout << "|    " << setw(15) << strSta << "|    " << setw(23) << strIn << "|    " << setw(15) << strOut << "|" <<endl;
    printf("--------------------------------------------------------------------\n");
}
// stack<int> sta;//栈
// stack<int> q;
void NonRecursivePredictionAnalysisOfLL1(){//LL1文法的非递归预测分析
    // while(!sta.empty()) sta.pop();
    printf("--------------------------------------------------------------------\n");
    printf("|     stack         |          input            |     output        |\n");
    printf("--------------------------------------------------------------------\n");
    top = 0;
    int len = strlen(textStr);
    textStr[len++] = '$';
    int i = 0;
    sta[top++] = (strToid["$"]);
    sta[top++] = (strToid["E"]);
    int x;
    Print(0, len, "");
    while(true){
        int x = sta[top - 1];
        if(x == strToid["$"]) break;
        int val = -1;
        char ch = 0;

        string sch = "";
        if(textStr[i] >= '0' && textStr[i] <= '9') sch = "num";
        else sch = sch + textStr[i];

        if(x == strToid["$"] || ele[x].type == 1){//终结符或$
            if(ele[x].Name == sch){
                top--;
                if(sch == "num"){
                    while(textStr[i] >= '0' && textStr[i] <= '9') i++;
                }
                else i++;
                Print(i, len, "");
            }
            else {
                Error();
                return;
            }
        }else {
            int v = strToid[sch];
            if(TableLL1[x][v].size()){
                top--;
                for(int j = TableLL1[x][v].size() - 1; j >= 1; j--){
                    if(TableLL1[x][v][j] != strToid["#"]) sta[top++] = (TableLL1[x][v][j]);
                }
                string strStr = "";
                for(int j = 0; j < TableLL1[x][v].size(); j++){
                    int now = TableLL1[x][v][j];
                    if(j == 0) strStr = strStr + ele[now].Name + "->";//cout << ele[now].Name << "->";
                    else strStr = strStr + ele[now].Name;//cout << ele[now].Name;
                }
                // cout << endl;
                Print(i, len, strStr);

            }else {
                Error();
                return;
            }
        }
    }
    if(i + 1 < len) Error();
    //(123+3213122)/2
}

void Init();
int main(){
    Init();
    return 0;
}
void Init(){
    PreProcess();//初始化
    Process();//由字符串转为标识符和数组

    QueryFirst();//求First集
    PrintFirst();//输出First集

    QueryFollow();//求Follow集
    PrintFollow();//输出Follow集

    PrintFirstAndFollowTable();//输出First和Follow表格

    CreatePredicitionTableOfLL1(); //构造LL1文法的预测分析表
    PrintPredicitionTableOfLL1(); //输出LL1文法的预测分析表

    
    while(true){
        memset(textStr, 0, sizeof(textStr));
        cout << "Please enter a text string, if you want to exit, please enter #:" << endl;
        scanf("%s", textStr);
        int len = strlen(textStr);
        if(len == 1 && textStr[0] == '#') break;

        NonRecursivePredictionAnalysisOfLL1();//LL1文法的非递归预测分析

        printf("\nUsing LL1 grammar analysis for non recursive analysis is complete!\n\n\n");
        system("pause");
    }

}
```
#### 方法三：$LR$语法分析程序实现自底向上的分析
* method3.cpp
```c++
#include <bits/stdc++.h>
#define LL long long
#define Inf 1e9
using namespace std;
const int maxn = 1010;
/*
E->E+T|E-T|T
T->T*F|T/F|F
F->(E)|num
.
 */
/*
消除左递归后
E->TS
S->AS|#
A->+T|-T
T->FW
W->BW|#
B->*F|/F
F->(E)|num
.
 */

/*
实验要求：在对输入的算术表达式进行分析的过程中，依次输出所采用的的产生式
方法3： 编写LR(1)语法分析程序，要求如下
 （1）构造识别该文法的所有活前缀的DFA
 （2）构造该文法的LR分析表
 （3）编程实现算法4.3，构造LR分析程序
 */
char oriG[maxn][maxn];//存放初始文法内容
int numGra;//文法的数量

char proG[maxn][maxn];//消除左递归后的文法内容

vector<int> G[maxn][maxn];//存放文法
int Count[maxn];//Count[x]表示非终结符x能推导出来的式子数量
map<string, int> strToid;//标识符名字与数字之间的映射

char textStr[maxn]; //要翻译的串

struct Element{
    int type;//type=0为非终结符，type=1为终结符,type=2为空,type=3为结束符号
    string Name;//标识
    Element(){};
    Element(int ttp, string NName){
        type = ttp;
        Name = NName;
    }
}ele[maxn];
int numEle;//终结符和非终结符的数量


vector<int> First[maxn];//First集
vector<int> Follow[maxn];//Follow集

int numGS;
vector<int> GS[maxn];



void PreProcess(){//划分终结符和非终结符，输入文法
    //ETSAFWB
    ele[1] = Element(0, "S");
    ele[2] = Element(0, "E");
    ele[3] = Element(0, "T");
    ele[4] = Element(0, "F");
    ele[5] = Element(1, "+");
    ele[6] = Element(1, "-");
    ele[7] = Element(1, "*");
    ele[8] = Element(1, "/");
    ele[9] = Element(1, "(");
    ele[10] = Element(1, ")");
    ele[11] = Element(1, "num");
    ele[12] = Element(3, "$");
    ele[13] = Element(2, "#");
    numEle = 13;
    for(int i = 1; i <= numEle; i++) strToid[ele[i].Name] = i;
    numGra = 4;
    for(int i = 1; i <= numGra; i++) {
        string now;
        if(i == 1) now = "S->E";
        else if (i == 2) now = "E->E+T|E-T|T";
        else if (i == 3) now = "T->T*F|T/F|F";
        else if (i == 4) now = "F->(E)|num";
        int len = now.length();
        for(int j = 0; j < len; j++){
            proG[i][j] = now[j];
        }
    }
    numGS = 9;
    for(int i = 0; i < numGS; i++) {
        string now;
        if(i == 0) now = "S->E";
        else if (i == 1) now = "E->E+T";
        else if (i == 2) now = "E->E-T";
        else if (i == 3) now = "E->T";
        else if (i == 4) now = "T->T*F";
        else if (i == 5) now = "T->T/F";
        else if (i == 6) now = "T->F";
        else if (i == 7) now = "F->(E)";
        else if (i == 8) now = "F->num";
        int len = now.length();
        for(int j = 0; j < len; j++){
            char ch = now[j];
            string snow = "";
            if(ch == 'n') {
                snow = snow + "num";
                j += 2;
            }
            else snow = snow + ch;
            if(j == 0) {
                GS[i].push_back(strToid[snow]);
                j += 2;
            } else {
                GS[i].push_back(strToid[snow]);
            }
        }
    }
}

void PrintGS(int i){//输出单个文法
    for(int j = 0; j < GS[i].size(); j++){
        if(j == 0) {
            cout << ele[GS[i][j]].Name << "->";
        }else {
            cout << ele[GS[i][j]].Name;
        }
    }
    cout << endl;
}

void Process(){//将字符串转为标识符和数组
    for(int d = 1; d <= numGra; d++){
        int len = strlen(proG[d]);
        string now = "";
        int i = 0;
        while(i < len && !(proG[d][i] == '-' && proG[d][i + 1] == '>')) {
            now = now + proG[d][i];
            i++;
        }
        int id = strToid[now];
        i += 2;
        while(i < len){
            int j = i;
            while(j < len && proG[d][j] != '|') j++;
            if(proG[d][j] == '|') j--;
            ++Count[id];
            now = "";
            for(int k = i; k <= j; k++){
                now = now + proG[d][k];
                if(strToid[now]) {
                    G[id][Count[id]].push_back(strToid[now]);
                    now = "";
                }
            }
            i = j + 2;
        }
    }
    for(int i = 1; i <= numEle; i++){
        if(Count[i]){
//            printf("%d->", i);
            cout << ele[i].Name << "->";
            for(int j = 1; j <= Count[i]; j++){
                for(int k = 0; k < G[i][j].size(); k++){
//                    printf("%d", G[i][j][k]);
                    cout << ele[G[i][j][k]].Name;
                }
                if(j != Count[i]) printf("|");
            }
            printf("\n");
        }
    }
    for(int i = 0; i < numGS; i++){//文法单个逐次输出
        PrintGS(i);
    }
}

bool FindInFirst(int id, int tar){//在id的First集合中找有没有tar
    for(int i = 0; i < First[id].size(); i++) {
        if(tar == First[id][i]) return true;
    }
    return false;
}

void FindFirst(int id){//找id的First集
    if(First[id].size()) return;
    for(int i = 1; i <= Count[id]; i++){
        int be = G[id][i][0];
        if(ele[be].type == 1){
            First[id].push_back(be);
        }else if(ele[be].type == 2){
            First[id].push_back(be);
        }else if(ele[be].type == 0){
            int num = 0;
            bool tag = false;
            for(int j = 0; j < G[id][i].size(); j++){
                int now = G[id][i][j];
                if(now == id) break;
                FindFirst(now);
                for(int k = 0; k < First[now].size(); k++){
                    if(First[now][k] != strToid["#"]) First[id].push_back(First[now][k]);
                }
                if(!FindInFirst(now, strToid["#"])) break;
                num++;
            }
            if(num == G[id][i].size()) First[id].push_back(strToid["#"]);
        }
    }
    sort(First[id].begin(), First[id].end());
    First[id].erase(unique(First[id].begin(), First[id].end()), First[id].end());
}
void QueryFirst(){//求FIRST集
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1){
            First[i].push_back(i);
        }else if(ele[i].type == 0){
            FindFirst(i);
        }
    }
}
void PrintFirst(){//输出First集
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        cout << "First(" << ele[i].Name << ") = {";
        for(int j = 0; j < First[i].size(); j++){
            int now = First[i][j];
            if(j != First[i].size() - 1) cout << ele[now].Name << ", ";
            else cout << ele[now].Name;
        }
        cout << "}" << endl;
    }
}

bool isQuery[maxn];


void FindFollow(int id){//找id的Follow集
    if(isQuery[id]) return; 
    isQuery[id] = true;
    for(int i = 1; i <= numEle; i++) if(ele[i].type == 0){
        for(int j = 1;j <= Count[i]; j++){
            for(int k = 0; k < G[i][j].size(); k++){
                if(G[i][j][k] == id){
                    if(k == G[i][j].size() - 1){
                        if(i == id) continue;
                        FindFollow(i);
                        for(int ii = 0; ii < Follow[i].size(); ii++){
                            Follow[id].push_back(Follow[i][ii]);
                        }
                    }else {
                        int x = G[i][j][k + 1];
                        for(int ii = 0; ii < First[x].size(); ii++){
                            if(First[x][ii] != strToid["#"]) Follow[id].push_back(First[x][ii]);
                        }
                        if(FindInFirst(x, strToid["#"]) && i != id){
                            FindFollow(i);
                            for(int ii = 0; ii < Follow[i].size(); ii++){
                                Follow[id].push_back(Follow[i][ii]);
                            }
                        }
                    }
                }
            }
        }
    }
    
    sort(Follow[id].begin(), Follow[id].end());
    Follow[id].erase(unique(Follow[id].begin(), Follow[id].end()), Follow[id].end());
}

void QueryFollow(){//求Follow集
    Follow[strToid["S"]].push_back(strToid["$"]);
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1) 
            Follow[i].push_back(strToid["$"]);
    }
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 0 && !isQuery[i]){
            // printf("i = %d\n", i);
            FindFollow(i);
        }
    }
}

void PrintFollow(){//输出Follow集
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0){
        cout << "Follow(" << ele[i].Name << ") = {";
        for(int j = 0; j < Follow[i].size(); j++){
            int now = Follow[i][j];
            if(j != Follow[i].size() - 1) cout << ele[now].Name << ", ";
            else cout << ele[now].Name;
        }
        cout << "}" << endl;
    }
}

void PrintFirstAndFollowTable(){//输出First和Follow表格
    cout << "\nFIRST set and FOLLOW set of grammer G:" << endl;
    printf("---------------------------------------------------------------------------------------------------\n");
    printf("|         |");
    for(int j = 1; j <= numEle; j++) if(ele[j].type == 0){//终结符或$
        cout << "          " << left << setw(11) << ele[j].Name << "|";
    }
    cout << endl;
    printf("---------------------------------------------------------------------------------------------------\n");
    printf("|  FIRST  |");
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        string now = "";
        for(int j = 0; j < First[i].size(); j++){
            now = now + ele[First[i][j]].Name;
            if(j != First[i].size() - 1) now = now + ", ";
        }
        cout << "   " << setw(16) << now << "  |";
    }
    cout << endl;
    printf("---------------------------------------------------------------------------------------------------\n");
    printf("|  FOLLOW |");
    for(int i = 1; i<= numEle; i++) if(ele[i].type == 0) {
        string now = "";
        for(int j = 0; j < Follow[i].size(); j++){
            now = now + ele[Follow[i][j]].Name;
            if(j != Follow[i].size() - 1) now = now + ", ";
        }
        cout << "   " << setw(16) << now << "  |";
    }
    cout << endl;
    
    printf("---------------------------------------------------------------------------------------------------\n");
    printf("\n");
    
}


void CreateDFAOfLR1(){//构造识别该文法的所有活前缀的DFA
    // See photos
}

struct Node{
    char tp;
    int v;
    Node(){};
    Node(char tpp, int vv){tp = tpp; v = vv;}
    //四种类型
    //tp = 'S', v 为数字,终结符移进
    //tp = 'R', v 为数字,规约
    //tp = 'M', v 为数字,非终结符移进
    //tp = 'A', v = -1, ACC
};

int numState = 30;//状态数，0~29
Node TableOfLR1[maxn][maxn];//分析表

void CreateAnalysisTableOfLR1(){//构造该文法的LR1分析表
    TableOfLR1[0][strToid["("]] = Node('S', 3);
    TableOfLR1[0][strToid["num"]] = Node('S', 5);
    TableOfLR1[0][strToid["E"]] = Node('M', 1);
    TableOfLR1[0][strToid["T"]] = Node('M', 2);
    TableOfLR1[0][strToid["F"]] = Node('M', 4);

    TableOfLR1[1][strToid["+"]] = Node('S', 6);
    TableOfLR1[1][strToid["-"]] = Node('S', 7);
    TableOfLR1[1][strToid["$"]] = Node('A', -1);

    TableOfLR1[2][strToid["+"]] = Node('R', 3);
    TableOfLR1[2][strToid["-"]] = Node('R', 3);
    TableOfLR1[2][strToid["*"]] = Node('S', 8);
    TableOfLR1[2][strToid["/"]] = Node('S', 9);
    TableOfLR1[2][strToid["$"]] = Node('R', 3);

    
    TableOfLR1[3][strToid["("]] = Node('S', 13);
    TableOfLR1[3][strToid["num"]] = Node('S', 14);
    TableOfLR1[3][strToid["E"]] = Node('M', 10);
    TableOfLR1[3][strToid["T"]] = Node('M', 11);
    TableOfLR1[3][strToid["F"]] = Node('M', 12);

    TableOfLR1[4][strToid["+"]] = Node('R', 6);
    TableOfLR1[4][strToid["-"]] = Node('R', 6);
    TableOfLR1[4][strToid["*"]] = Node('R', 6);
    TableOfLR1[4][strToid["/"]] = Node('R', 6);
    TableOfLR1[4][strToid["$"]] = Node('R', 6);

    
    TableOfLR1[5][strToid["+"]] = Node('R', 8);
    TableOfLR1[5][strToid["-"]] = Node('R', 8);
    TableOfLR1[5][strToid["*"]] = Node('R', 8);
    TableOfLR1[5][strToid["/"]] = Node('R', 8);
    TableOfLR1[5][strToid["$"]] = Node('R', 8);

    TableOfLR1[6][strToid["("]] = Node('S', 3);
    TableOfLR1[6][strToid["num"]] = Node('S', 5);
    TableOfLR1[6][strToid["T"]] = Node('M', 15);
    TableOfLR1[6][strToid["F"]] = Node('M', 4);
    
    TableOfLR1[7][strToid["("]] = Node('S', 3);
    TableOfLR1[7][strToid["num"]] = Node('S', 5);
    TableOfLR1[7][strToid["T"]] = Node('M', 16);
    TableOfLR1[7][strToid["F"]] = Node('M', 4);
    
    TableOfLR1[8][strToid["("]] = Node('S', 3);
    TableOfLR1[8][strToid["num"]] = Node('S', 5);
    TableOfLR1[8][strToid["F"]] = Node('M', 17);
    
    TableOfLR1[9][strToid["("]] = Node('S', 3);
    TableOfLR1[9][strToid["num"]] = Node('S', 5);
    TableOfLR1[9][strToid["F"]] = Node('M', 18);

    
    TableOfLR1[10][strToid["+"]] = Node('S', 20);
    TableOfLR1[10][strToid["-"]] = Node('S', 21);
    TableOfLR1[10][strToid[")"]] = Node('S', 19);
    
    TableOfLR1[11][strToid["+"]] = Node('R', 3);
    TableOfLR1[11][strToid["-"]] = Node('R', 3);
    TableOfLR1[11][strToid["*"]] = Node('S', 22);
    TableOfLR1[11][strToid["/"]] = Node('S', 23);
    TableOfLR1[11][strToid[")"]] = Node('R', 3);
    
    TableOfLR1[12][strToid["+"]] = Node('R', 6);
    TableOfLR1[12][strToid["-"]] = Node('R', 6);
    TableOfLR1[12][strToid["*"]] = Node('R', 6);
    TableOfLR1[12][strToid["/"]] = Node('R', 6);
    TableOfLR1[12][strToid[")"]] = Node('R', 6);
    
    TableOfLR1[13][strToid["("]] = Node('S', 13);
    TableOfLR1[13][strToid["num"]] = Node('S', 14);
    TableOfLR1[13][strToid["E"]] = Node('M', 24);
    TableOfLR1[13][strToid["T"]] = Node('M', 11);
    TableOfLR1[13][strToid["F"]] = Node('M', 12);
    
    TableOfLR1[14][strToid["+"]] = Node('R', 8);
    TableOfLR1[14][strToid["-"]] = Node('R', 8);
    TableOfLR1[14][strToid["*"]] = Node('R', 8);
    TableOfLR1[14][strToid["/"]] = Node('R', 8);
    TableOfLR1[14][strToid[")"]] = Node('R', 8);
    
    TableOfLR1[15][strToid["+"]] = Node('R', 1);
    TableOfLR1[15][strToid["-"]] = Node('R', 1);
    TableOfLR1[15][strToid["*"]] = Node('S', 8);
    TableOfLR1[15][strToid["/"]] = Node('S', 9);
    TableOfLR1[15][strToid["$"]] = Node('R', 1);

    TableOfLR1[16][strToid["+"]] = Node('R', 2);
    TableOfLR1[16][strToid["-"]] = Node('R', 2);
    TableOfLR1[16][strToid["*"]] = Node('S', 8);
    TableOfLR1[16][strToid["/"]] = Node('S', 9);
    TableOfLR1[16][strToid["$"]] = Node('R', 2);
    
    TableOfLR1[17][strToid["+"]] = Node('R', 4);
    TableOfLR1[17][strToid["-"]] = Node('R', 4);
    TableOfLR1[17][strToid["*"]] = Node('R', 4);
    TableOfLR1[17][strToid["/"]] = Node('R', 4);
    TableOfLR1[17][strToid["$"]] = Node('R', 4);
    
    TableOfLR1[18][strToid["+"]] = Node('R', 5);
    TableOfLR1[18][strToid["-"]] = Node('R', 5);
    TableOfLR1[18][strToid["*"]] = Node('R', 5);
    TableOfLR1[18][strToid["/"]] = Node('R', 5);
    TableOfLR1[18][strToid["$"]] = Node('R', 5);
    
    TableOfLR1[19][strToid["+"]] = Node('R', 7);
    TableOfLR1[19][strToid["-"]] = Node('R', 7);
    TableOfLR1[19][strToid["*"]] = Node('R', 7);
    TableOfLR1[19][strToid["/"]] = Node('R', 7);
    TableOfLR1[19][strToid["$"]] = Node('R', 7);
    
    TableOfLR1[20][strToid["("]] = Node('S', 13);
    TableOfLR1[20][strToid["num"]] = Node('S', 14);
    TableOfLR1[20][strToid["T"]] = Node('M', 25);
    TableOfLR1[20][strToid["F"]] = Node('M', 12);

    TableOfLR1[21][strToid["("]] = Node('S', 13);
    TableOfLR1[21][strToid["num"]] = Node('S', 14);
    TableOfLR1[21][strToid["T"]] = Node('M', 26);
    TableOfLR1[21][strToid["F"]] = Node('M',12);

    TableOfLR1[22][strToid["("]] = Node('S', 13);
    TableOfLR1[22][strToid["num"]] = Node('S', 14);
    TableOfLR1[22][strToid["F"]] = Node('M', 27);
    
    TableOfLR1[23][strToid["("]] = Node('S', 13);
    TableOfLR1[23][strToid["num"]] = Node('S', 14);
    TableOfLR1[23][strToid["F"]] = Node('M', 28);

    TableOfLR1[24][strToid["+"]] = Node('S', 20);
    TableOfLR1[24][strToid["-"]] = Node('S', 21);
    TableOfLR1[24][strToid[")"]] = Node('S', 29);

    TableOfLR1[25][strToid["+"]] = Node('R', 1);
    TableOfLR1[25][strToid["-"]] = Node('R', 1);
    TableOfLR1[25][strToid["*"]] = Node('S', 22);
    TableOfLR1[25][strToid["/"]] = Node('S', 23);
    TableOfLR1[25][strToid[")"]] = Node('R', 1);
    
    TableOfLR1[26][strToid["+"]] = Node('R', 2);
    TableOfLR1[26][strToid["-"]] = Node('R', 2);
    TableOfLR1[26][strToid["*"]] = Node('S', 22);
    TableOfLR1[26][strToid["/"]] = Node('S', 23);
    TableOfLR1[26][strToid[")"]] = Node('R', 2);
    
    TableOfLR1[27][strToid["+"]] = Node('R', 4);
    TableOfLR1[27][strToid["-"]] = Node('R', 4);
    TableOfLR1[27][strToid["*"]] = Node('R', 4);
    TableOfLR1[27][strToid["/"]] = Node('R', 4);
    TableOfLR1[27][strToid[")"]] = Node('R', 4);
    
    TableOfLR1[28][strToid["+"]] = Node('R', 5);
    TableOfLR1[28][strToid["-"]] = Node('R', 5);
    TableOfLR1[28][strToid["*"]] = Node('R', 5);
    TableOfLR1[28][strToid["/"]] = Node('R', 5);
    TableOfLR1[28][strToid[")"]] = Node('R', 5);
    
    TableOfLR1[29][strToid["+"]] = Node('R', 7);
    TableOfLR1[29][strToid["-"]] = Node('R', 7);
    TableOfLR1[29][strToid["*"]] = Node('R', 7);
    TableOfLR1[29][strToid["/"]] = Node('R', 7);
    TableOfLR1[29][strToid[")"]] = Node('R', 7);
}

string IntToString(int val){//整形转为字符串
    char snow[15];
    memset(snow, 0, sizeof(snow));
    itoa(val, snow, 10);
    string strnow = snow;
    return strnow;
}

void PrintAnalysisTableOfLR1(){//输出该文法的LR1分析表

    printf("-------------------------------------------------------------------------------------------------------------\n");
    cout << "|  " << setw(6) << "state" << "|" ; 
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 1 || ele[i].type == 3){
            cout << "  " << setw(6) << ele[i].Name << "|";
        }
    }
    for(int i = 1; i <= numEle; i++){
        if(ele[i].type == 0 && i != strToid["S"]){
            cout << "  " << setw(6) << ele[i].Name << "|";
        }
    }
    cout << endl;
    printf("-------------------------------------------------------------------------------------------------------------\n");
    for(int d = 0; d < numState; d++){
        cout << "| " << setw(6) << IntToString(d) << " |";
        for(int i = 1; i <= numEle; i++){
            if(ele[i].type == 1 || ele[i].type == 3){
                if(TableOfLR1[d][i].v == 0) cout << "        " << "|";
                else {
                    string now = "";
                    if(TableOfLR1[d][i].tp == 'A') now = "ACC";
                    else if(TableOfLR1[d][i].tp == 'M') now = now + IntToString(TableOfLR1[d][i].v);
                    else {
                        now = now + TableOfLR1[d][i].tp;
                        now = now + IntToString(TableOfLR1[d][i].v);
                    }
                    cout << "  " << setw(6) << now << "|";
                }
            }
        }
        for(int i = 1; i <= numEle; i++){
            if(ele[i].type == 0 && i != strToid["S"]){
                // printf("<<%c%d>> ", TableOfLR1[d][i].tp, TableOfLR1[d][i].v);
                if(TableOfLR1[d][i].v == 0) cout << "        " << "|";
                else {
                    string now = "";
                    if(TableOfLR1[d][i].tp == 'A') now = "ACC";
                    else if(TableOfLR1[d][i].tp == 'M') now = now + IntToString(TableOfLR1[d][i].v);
                    else now = now + TableOfLR1[d][i].tp + IntToString(TableOfLR1[d][i].v);
                    cout << "  " << setw(6) << now << "|";
                }
            }
        }
        cout << endl;
        printf("-------------------------------------------------------------------------------------------------------------\n");
    }
}

void Error(){
    cout << "Error Occurred!" << endl;
}
void GetGS(string now, int i){
    for(int j = 0; j < GS[i].size(); j++){
        if(j == 0) {
            now = now + ele[GS[i][j]].Name + "->";
        }else {
            now = now + ele[GS[i][j]].Name;
        }
    }
}
int staState[maxn], topState;
int staLabel[maxn], topLabel;
// stack<int> staState;//状态栈
// stack<int> staLabel;//符号栈

void Print(int pos, int len, string strOut){
    string strState = "";
    string strLabel = "";
    string strIn = "";
    // string strOut = "";
    for(int i = 0; i < topState; i++) strState = strState + IntToString(staState[i]) + " ";
    for(int i = 0; i < topLabel; i++) strLabel = strLabel + ele[staLabel[i]].Name;
    
    for(int i = pos; i < len; i++) strIn = strIn + textStr[i];
    cout << "|    " << setw(23) << strState << "|    " << setw(23) << strLabel <<"|    " << setw(23) << strIn << "|    " << setw(17) << strOut << "|" <<endl;
    printf("-----------------------------------------------------------------------------------------------------------\n");
}

void AnalysisOfLR1(){//LR1文法的分析
    // while(!staState.empty()) staState.pop();
    // while(!staLabel.empty()) staLabel.pop();
    printf("-----------------------------------------------------------------------------------------------------------\n");
    printf("|        stackState         |        stackSymble        |            input          |        output       |\n");
    printf("-----------------------------------------------------------------------------------------------------------\n");
    topState = 0;
    topLabel = 0;
    int len = strlen(textStr);
    textStr[len++] = '$';
    int i = 0;
    staState[topState++] = (0);
    staLabel[topLabel++] = strToid["#"];
    
    do{
        int x = staState[topState - 1];
        string sch = "";
        if(textStr[i] >= '0' && textStr[i] <= '9') sch = "num";
        else sch = sch + textStr[i];
        if(TableOfLR1[x][strToid[sch]].tp == 'S'){
            string now = "";
            now = now + "Shift " + IntToString(TableOfLR1[x][strToid[sch]].v);
            Print(i, len, now);
            staState[topState++] = (TableOfLR1[x][strToid[sch]].v);
            staLabel[topLabel++] = (strToid[sch]);
            if(sch == "num"){
                while(textStr[i] >= '0' && textStr[i] <= '9') i++;
            }
            else i++;
        }
        else {
            if(TableOfLR1[x][strToid[sch]].tp == 'R'){
                int id = TableOfLR1[x][strToid[sch]].v;
                int num = GS[id].size() - 1;
                string now = "";
                now = now + "reduce by ";
                // GetGS(now, id);
                for(int j = 0; j < GS[id].size(); j++){
                    if(j == 0) {
                        now = now + ele[GS[id][j]].Name + "->";
                    }else {
                        now = now + ele[GS[id][j]].Name;
                    }
                }
                Print(i, len, now);
                for(int j = 1; j <= num; j++) topState--, topLabel--;
                x = staState[topState - 1];
                staLabel[topLabel++] = (GS[id][0]);
                staState[topState++] = (TableOfLR1[x][GS[id][0]].v);
                // PrintGS(id);
            }
            else if(TableOfLR1[x][strToid[sch]].tp == 'A') {
                string now = "";
                now = now + "ACC";
                Print(i, len, now);
                break;
            }
            else {
                Error();
                return;
            }
        }
    }while(true);
    /*
    while(!staLabel.empty()) {
        int x = staLabel.top();
        staLabel.pop();
        cout << ele[x].Name;
    }
    cout << endl;
    */
    
}

void Init();
int main(){
    Init();
    return 0;
}
void Init(){
    PreProcess();//初始化
    Process();//由字符串转为标识符和数组

    QueryFirst();//求First集
    PrintFirst();//输出First集

    QueryFollow();//求Follow集
    PrintFollow();//输出Follow集

    PrintFirstAndFollowTable();//输出First和Follow表格

    CreateDFAOfLR1(); //构造识别该文法的所有活前缀的DFA

    CreateAnalysisTableOfLR1(); //构造该文法的LR1分析表
    PrintAnalysisTableOfLR1(); //输出该文法的LR1分析表

    while(true){
        memset(textStr, 0, sizeof(textStr));
        cout << "Please enter a text string, if you want to exit, please enter #:" << endl;
        scanf("%s", textStr);
        int len = strlen(textStr);
        if(len == 1 && textStr[0] == '#') break;

        AnalysisOfLR1();//LR1文法的分析
        
        printf("\nUsing LR1 grammar analysis for non recursive analysis is complete!\n\n\n");
        
        system("pause");
    }
    
}
```
#### 方法四：利用$YACC$自动生成语法分析程序，调用$LEX$自动生成的词法分析程序
* YACC.y
```c++
%{

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#define YYSTYPE double	/* doble type for YACC stack; for yylval */

int yylex(void);
int yyerror(char *);

%}

%token NUM

%%

line	:	line expr '\n'	{printf("Success!\n");}
     	|	line '\n'
	|	/* error */
	|	error '\n'	{yyerror("reenter last line:");}
    	;
expr	:	expr '+' term	{$$ = $1 + $3;	printf("E->E+T\n");}
     	|	expr '-' term	{$$ = $1 - $3;	printf("E->E-T\n");}
	|	term		{		printf("E->T\n");}
	;
term	:	term '*' factor	{$$ = $1 * $3;	printf("T->T*F\n");}
     	|	term '/' factor	{$$ = $1 / $3;	printf("T->T/F\n");}
	|	factor		{		printf("T->F\n");}
	;
factor	:	'(' expr ')'	{$$ = $2;	printf("F->(E)\n");}
       	|	NUM	{		printf("F->num\n");}
	;

%%

int yylex() {
  int c;
  while ((c = getchar()) == ' ') ;
  if (c == '.' || isdigit(c)) {
    ungetc(c, stdin);
    scanf("%lf", &yylval);
    return NUM;
  }
  return c;
}

int yyerror(char *s) {
  fprintf(stderr, "error: %s\n", s);
}

int main()
{
  puts("Input your string: ");
  return yyparse();
}

```